;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package cljctools.ipfs.dht.proto
;;;----------------------------------------------------------------------------------
(ns cljctools.ipfs.dht.proto
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :as serdes.core]
            [protojure.protobuf.serdes.complex :as serdes.complex]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as serdes.stream]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->Record)
(declare ecis->Record)
(declare new-Record)
(declare cis->Message)
(declare ecis->Message)
(declare new-Message)
(declare cis->Message-Peer)
(declare ecis->Message-Peer)
(declare new-Message-Peer)

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Enumerations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; Message-MessageType
;-----------------------------------------------------------------------------
(def Message-MessageType-val2label {
  0 :put-value
  1 :get-value
  2 :add-provider
  3 :get-providers
  4 :find-node
  5 :ping})

(def Message-MessageType-label2val (set/map-invert Message-MessageType-val2label))

(defn cis->Message-MessageType [is]
  (let [val (serdes.core/cis->Enum is)]
    (get Message-MessageType-val2label val val)))

(defn- get-Message-MessageType [value]
  {:pre [(or (int? value) (contains? Message-MessageType-label2val value))]}
  (get Message-MessageType-label2val value value))

(defn write-Message-MessageType
  ([tag value os] (write-Message-MessageType tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-Message-MessageType value) os)))

;-----------------------------------------------------------------------------
; Message-ConnectionType
;-----------------------------------------------------------------------------
(def Message-ConnectionType-val2label {
  0 :not-connected
  1 :connected
  2 :can-connect
  3 :cannot-connect})

(def Message-ConnectionType-label2val (set/map-invert Message-ConnectionType-val2label))

(defn cis->Message-ConnectionType [is]
  (let [val (serdes.core/cis->Enum is)]
    (get Message-ConnectionType-val2label val val)))

(defn- get-Message-ConnectionType [value]
  {:pre [(or (int? value) (contains? Message-ConnectionType-label2val value))]}
  (get Message-ConnectionType-label2val value value))

(defn write-Message-ConnectionType
  ([tag value os] (write-Message-ConnectionType tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-Message-ConnectionType value) os)))



;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; Record
;-----------------------------------------------------------------------------
(defrecord Record-record [key value timeReceived]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:key this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:value this) os)
    (serdes.core/write-String 5  {:optimize true} (:timeReceived this) os))
  pb/TypeReflection
  (gettype [this]
    "cljctools.ipfs.dht.proto.Record"))

(s/def :cljctools.ipfs.dht.proto.Record/key bytes?)
(s/def :cljctools.ipfs.dht.proto.Record/value bytes?)
(s/def :cljctools.ipfs.dht.proto.Record/timeReceived string?)
(s/def ::Record-spec (s/keys :opt-un [:cljctools.ipfs.dht.proto.Record/key :cljctools.ipfs.dht.proto.Record/value :cljctools.ipfs.dht.proto.Record/timeReceived ]))
(def Record-defaults {:key (byte-array 0) :value (byte-array 0) :timeReceived "" })

(defn cis->Record
  "CodedInputStream to Record"
  [is]
  (->> (tag-map Record-defaults
         (fn [tag index]
             (case index
               1 [:key (serdes.core/cis->Bytes is)]
               2 [:value (serdes.core/cis->Bytes is)]
               5 [:timeReceived (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Record-record)))

(defn ecis->Record
  "Embedded CodedInputStream to Record"
  [is]
  (serdes.core/cis->embedded cis->Record is))

(defn new-Record
  "Creates a new instance from a map, similar to map->Record except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Record-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Record-spec init))))]}
  (-> (merge Record-defaults init)
      (map->Record-record)))

(defn pb->Record
  "Protobuf to Record"
  [input]
  (cis->Record (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Record-meta {:type "cljctools.ipfs.dht.proto.Record" :decoder pb->Record})

;-----------------------------------------------------------------------------
; Message
;-----------------------------------------------------------------------------
(defrecord Message-record [type clusterLevelRaw key record closerPeers providerPeers]
  pb/Writer
  (serialize [this os]
    (write-Message-MessageType 1  {:optimize true} (:type this) os)
    (serdes.core/write-Int32 10  {:optimize true} (:clusterLevelRaw this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:key this) os)
    (serdes.core/write-Bytes 3  {:optimize true} (:record this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 8 (:closerPeers this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 9 (:providerPeers this) os))
  pb/TypeReflection
  (gettype [this]
    "cljctools.ipfs.dht.proto.Message"))

(s/def :cljctools.ipfs.dht.proto.Message/type (s/or :keyword keyword? :int int?))
(s/def :cljctools.ipfs.dht.proto.Message/clusterLevelRaw int?)
(s/def :cljctools.ipfs.dht.proto.Message/key bytes?)
(s/def :cljctools.ipfs.dht.proto.Message/record bytes?)


(s/def ::Message-spec (s/keys :opt-un [:cljctools.ipfs.dht.proto.Message/type :cljctools.ipfs.dht.proto.Message/clusterLevelRaw :cljctools.ipfs.dht.proto.Message/key :cljctools.ipfs.dht.proto.Message/record ]))
(def Message-defaults {:type (Message-MessageType-val2label 0) :clusterLevelRaw 0 :key (byte-array 0) :record (byte-array 0) :closerPeers [] :providerPeers [] })

(defn cis->Message
  "CodedInputStream to Message"
  [is]
  (->> (tag-map Message-defaults
         (fn [tag index]
             (case index
               1 [:type (cis->Message-MessageType is)]
               10 [:clusterLevelRaw (serdes.core/cis->Int32 is)]
               2 [:key (serdes.core/cis->Bytes is)]
               3 [:record (serdes.core/cis->Bytes is)]
               8 [:closerPeers (serdes.complex/cis->repeated ecis->Message-Peer is)]
               9 [:providerPeers (serdes.complex/cis->repeated ecis->Message-Peer is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Message-record)))

(defn ecis->Message
  "Embedded CodedInputStream to Message"
  [is]
  (serdes.core/cis->embedded cis->Message is))

(defn new-Message
  "Creates a new instance from a map, similar to map->Message except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Message-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Message-spec init))))]}
  (-> (merge Message-defaults init)
      (cond-> (some? (get init :closerPeers)) (update :closerPeers #(map new-Message-Peer %)))
      (cond-> (some? (get init :providerPeers)) (update :providerPeers #(map new-Message-Peer %)))
      (map->Message-record)))

(defn pb->Message
  "Protobuf to Message"
  [input]
  (cis->Message (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Message-meta {:type "cljctools.ipfs.dht.proto.Message" :decoder pb->Message})

;-----------------------------------------------------------------------------
; Message-Peer
;-----------------------------------------------------------------------------
(defrecord Message-Peer-record [id addrs connection]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:id this) os)
    (serdes.complex/write-repeated serdes.core/write-Bytes 2 (:addrs this) os)
    (write-Message-ConnectionType 3  {:optimize true} (:connection this) os))
  pb/TypeReflection
  (gettype [this]
    "cljctools.ipfs.dht.proto.Message-Peer"))

(s/def :cljctools.ipfs.dht.proto.Message-Peer/id bytes?)
(s/def :cljctools.ipfs.dht.proto.Message-Peer/addrs (s/every bytes?))
(s/def :cljctools.ipfs.dht.proto.Message-Peer/connection (s/or :keyword keyword? :int int?))
(s/def ::Message-Peer-spec (s/keys :opt-un [:cljctools.ipfs.dht.proto.Message-Peer/id :cljctools.ipfs.dht.proto.Message-Peer/addrs :cljctools.ipfs.dht.proto.Message-Peer/connection ]))
(def Message-Peer-defaults {:id (byte-array 0) :addrs [] :connection (Message-ConnectionType-val2label 0) })

(defn cis->Message-Peer
  "CodedInputStream to Message-Peer"
  [is]
  (->> (tag-map Message-Peer-defaults
         (fn [tag index]
             (case index
               1 [:id (serdes.core/cis->Bytes is)]
               2 [:addrs (serdes.complex/cis->repeated serdes.core/cis->Bytes is)]
               3 [:connection (cis->Message-ConnectionType is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Message-Peer-record)))

(defn ecis->Message-Peer
  "Embedded CodedInputStream to Message-Peer"
  [is]
  (serdes.core/cis->embedded cis->Message-Peer is))

(defn new-Message-Peer
  "Creates a new instance from a map, similar to map->Message-Peer except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Message-Peer-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Message-Peer-spec init))))]}
  (-> (merge Message-Peer-defaults init)
      (map->Message-Peer-record)))

(defn pb->Message-Peer
  "Protobuf to Message-Peer"
  [input]
  (cis->Message-Peer (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Message-Peer-meta {:type "cljctools.ipfs.dht.proto.Message-Peer" :decoder pb->Message-Peer})

